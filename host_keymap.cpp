
#include <boost/tokenizer.hpp>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>

#include "xkbcommon/xkbcommon.h"

#include <iostream>
#include <exception>
#include <string>
#include <sstream>
#include <map>
#include <string>
#include <fstream>

#include "static_maps.h"

struct Settings {
   std::string base_path_;
   
   void parse(int argc, const char** argv)
   {
      using namespace boost::program_options;
      options_description desc("Allowed settings");
      desc.add_options()
         // First parameter describes option name/short name
         // The second is parameter to option
         // The third is description
         ("help,h", "print usage message")
         ("base_path,b", value(&base_path_), "base path for directory creation")
         ;
      
      variables_map vm;
      store(parse_command_line(argc, argv, desc), vm);
      
      if(base_path_.empty()) {
         boost::filesystem::path full_path(boost::filesystem::current_path());
         std::cout << "Basepath undefined. Setting it to PWD=" << full_path << std::endl;
         base_path_ = full_path.string();
      }
   }
};

const char *kaleidoscope_mod_macros[] = {
   "LCTRL",
   "LALT",
   "RALT",
   "LSHIFT",
   "LGUI"
};

int mod_key_codes[] = {
   37, // LCTRL
   64, // LALT
   108, // RALT
   50, // LSHIFT
   133 // LGUI
};

unsigned int countSetBits(int i) 
{ 
   unsigned int n = (unsigned int)i;
    unsigned int count = 0; 
    while (n) { 
        count += n & 1; 
        n >>= 1; 
    } 
    return count; 
} 

std::string keySymToUtf8(xkb_keysym_t key_sym) {
   constexpr std::size_t utf8_buffer_size = 7;
   char utf8_buffer[utf8_buffer_size];
   
   auto utf8_bytes_written 
      = xkb_keysym_to_utf8(key_sym , utf8_buffer, utf8_buffer_size);
      
   return std::string{utf8_buffer};
}

struct KaleidoscopeKeycodeInfo {
   xkb_keysym_t key_sym_;
   const char *kaleidoscope_key_;
   int modifier_bits_;
   
   std::string format() const {
      std::ostringstream s;
      for(int i = 0; i < 5; i++) {
         if(modifier_bits_ & (1 << i)) {
            s << kaleidoscope_mod_macros[i] << "(";
         }
      }
      s << kaleidoscope_key_;
      for(int i = 0; i < 5; i++) {
         if(modifier_bits_ & (1 << i)) {
            s << ")";
         }
      }
      return s.str();
   }
};

struct KeymapInfo {
   
   std::string layout_;
   std::string variant_;
   
   std::map<char, KaleidoscopeKeycodeInfo> ascii_to_kaleidoscope_key_code_;
   std::map<uint32_t, KaleidoscopeKeycodeInfo> unicode_to_kaleidoscope_key_code_;
   std::map<std::string, KaleidoscopeKeycodeInfo> non_printable_to_kaleidoscope_key_code_;
   
   void dump()
   {
      std::cout << "ascii:" << std::endl;
      for(const auto &entry: ascii_to_kaleidoscope_key_code_) {
         std::cout << "   " << entry.first 
            << ": " << entry.second.format() << std::endl;
      }
      
      std::cout << "unicode:" << std::endl;
      for(const auto &entry: unicode_to_kaleidoscope_key_code_) {
         std::cout << "   " << keySymToUtf8(entry.second.key_sym_)
            << ": " << entry.second.format() << std::endl;
      }
      
      std::cout << "non printable:" << std::endl;
      for(const auto &entry: non_printable_to_kaleidoscope_key_code_) {
         std::cout << "   " << entry.first 
            << ": " << entry.second.format() << std::endl;
      }
   }
   
   void writeConfigFile(const Settings &settings) {
      
      std::ostringstream o;
      o << settings.base_path_ << "/" << layout_;
      
      if(!variant_.empty()) {
         o << "/" << variant_;
      }
      
      boost::system::error_code ec;
      if (!boost::filesystem::create_directories(o.str(), ec)) {
         std::cerr << ec.message() << ": " << o.str() << "\n";
         throw std::runtime_error("Couldn't create directory");
      }
      
      std::ofstream file(o.str() + "/keymap.h");
      
      this->writeConfigFile(file);
   }
   
   void writeConfigFile(std::ostream &file) {
      file << 
"/* Kaleidoscope - Firmware for computer input devices\n"
" * Copyright (C) 2013-2019  Keyboard.io, Inc.\n"
" *\n"
" * This program is free software: you can redistribute it and/or modify it under\n"
" * the terms of the GNU General Public License as published by the Free Software\n"
" * Foundation, version 3.\n"
" *\n"
" * This program is distributed in the hope that it will be useful, but WITHOUT\n"
" * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"
" * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n"
" * details.\n"
" *\n"
" * You should have received a copy of the GNU General Public License along with\n"
" * this program. If not, see <http://www.gnu.org/licenses/>.\n"
" */\n"
"\n"
"#pragma once\n"
"\n"
"#include \"kaleidoscope/host_keymap/common.h\"\n"
"\n"
"// This file was autogenerated on Ubuntu 19.10 based on information\n"
"// provided by the XKB X11 system (mostly libxkbcommon).\n"
"\n";
      file << "// layout: " << layout_ << "\n";
      file << "// variant: " << variant_ << "\n";
      file << "\n";
      file << "#define _HOST_KEYMAP_ASCII_KEYMAP(OP) \\\n";

      for(const auto &entry: ascii_to_kaleidoscope_key_code_) {
         file << "   OP(\'" << entry.first << "\', "
            << entry.second.format() << ") \\\n";
      }
      file << "\n";
      
      file << "#define _HOST_KEYMAP_UNICODE_KEYMAP(OP) \\\n";
      
      for(const auto &entry: unicode_to_kaleidoscope_key_code_) {
         file << "   OP(L'" << keySymToUtf8(entry.second.key_sym_) << "', "
            << entry.second.format() << ") \\\n";
      }
      file << "\n";
      
      file << "#define _HOST_KEYMAP_NON_PRINTABLE_KEYMAP(OP) \\\n";
      
      for(const auto &entry: non_printable_to_kaleidoscope_key_code_) {
         file << "   OP(" << entry.first << ", "
            << entry.second.format() << ") \\\n";
      }
      file << "\n";
      
      file << "\n";
      file << "namespace kaleidoscope {\n";
      file << "namespace host_keymap {\n";
      file << "namespace linux {\n";
      file << "namespace " << layout_ << " {\n";
      file << "namespace " << variant_ << " {\n";
      file << "\n";
      file << "HOST_KEYMAP_ASCII_CONVERTER(\n";
      file << "   _HOST_KEYMAP_ASCII_KEYMAP,\n";
      file << "   CharParsingStandardFallback\n";
      file << ")\n";
      file << "\n";
      file << "HOST_KEYMAP_UNICODE_CONVERTER(\n";
      file << "   _HOST_KEYMAP_UNICODE_KEYMAP,\n";
      file << "   WCharParsingStandardFallback\n";
      file << ")\n";
      file << "\n";
      file << "HOST_KEYMAP_NON_PRINTABLE_CONVERTER(\n";
      file << "   _HOST_KEYMAP_NON_PRINTABLE_KEYMAP,\n";
      file << "   NonPrintableParsingStandardFallback\n";
      file << ")\n";
      file << "\n";
      file << "} // namespace " << variant_ << "\n";
      file << "} // namespace " << layout_ << "\n";
      file << "} // namespace linux\n";
      file << "} // namespace host_keymap\n";
      file << "} // namespace kaleidoscope\n";
      file << "\n";
      file << "#undef _HOST_KEYMAP_ASCII_KEYMAP\n";
      file << "#undef _HOST_KEYMAP_UNICODE_KEYMAP\n";
      file << "#undef _HOST_KEYMAP_NON_PRINTABLE_KEYMAP\n";
      file << "\n";
   }
};

class LayoutProcessor {
   
   public:
      
      LayoutProcessor(const Settings &settings);
      ~LayoutProcessor();
      
      void readKeyboardLayouts();
      void processLayout(const char *layout, const char *variant);
   
      void parseKeymap(KeymapInfo &keymap_info,
                       struct xkb_keymap *keymap, 
                    struct xkb_rule_names *rule_names);
      
      void handleKeysym(KeymapInfo &keymap_info, 
                     int key_event, 
                     int modifier_bits,
                     xkb_keysym_t key_sym);
      
      void updateMods(struct xkb_state *state, 
                      int old_mods, int new_mods);
      
   private:
      
      const Settings &settings_;
      struct xkb_context *xkb_context_;
};

   LayoutProcessor
      ::LayoutProcessor(const Settings &settings) 
   :  settings_{settings}
{
   xkb_context_ = xkb_context_new(XKB_CONTEXT_NO_DEFAULT_INCLUDES);
   
   if(!xkb_context_) {
      throw std::runtime_error("Unable to create xkbcommon context");
   }
   
   if(!xkb_context_include_path_append(xkb_context_, "/usr/share/X11/xkb/")) {
      throw std::runtime_error("Failed appending include path");
   }
}
   
   LayoutProcessor
      ::~LayoutProcessor()
{
   xkb_context_unref(xkb_context_);
   xkb_context_ = nullptr;
}

std::string getStdoutFromCommand(std::string cmd) {

   std::string data;
   FILE * stream;
   const int max_buffer = 256;
   char buffer[max_buffer];
   cmd.append(" 2>&1");

   stream = popen(cmd.c_str(), "r");
   if (stream) {
      while (!feof(stream)) {
         if (fgets(buffer, max_buffer, stream) != NULL) {
            data.append(buffer);
         }
      }
   }
   pclose(stream);
         
   return data;
}

int keyEventToKeyCode(int key_event) {
   return key_event + 8;
}

int keyCodeToKeyEvent(int key_code) {
   return key_code - 8;
}

/*void
      ::addKeysymToKeymapInfo(KeymapInfo &keymap_info,
                               xkb_keysym_t key_sym,
           */  

std::string getModifiersString(int modifier_bits) {
   std::ostringstream s;
   
   for(int i = 0; i < 5; i++) {
      if(modifier_bits & (1 << i)) {
         s << kaleidoscope_mod_macros[i] << ", ";
      }
   }
   
   return s.str();
}

template<typename _MapType>
void addIfLessModifiersUsed(_MapType &m,
                            const typename _MapType::key_type &key,
                            const KaleidoscopeKeycodeInfo &value,
                            int num_bits_set)
{
   auto it = m.find(key);
   
   bool add_new_entry = true;
   if(it != m.end()) {
      if(num_bits_set >= countSetBits(it->second.modifier_bits_)) {
         add_new_entry = false;
      }
   }
   
   if(add_new_entry) {
      m[key] = value;
   }
}


void
   LayoutProcessor
      ::handleKeysym(KeymapInfo &keymap_info, 
                     int key_event, 
                     int modifier_bits,
                     xkb_keysym_t key_sym)
{
   // First check if the key_sym is
   if(key_sym == XKB_KEY_VoidSymbol) { return; }
   
   auto kaleidoscope_key_name = kaleidoscopeNameFromKeyEvent(key_event);
         
   KaleidoscopeKeycodeInfo key_info{
      key_sym,
      kaleidoscope_key_name,
      modifier_bits
   };
   
   auto num_modifier_bits_set = countSetBits(modifier_bits);
   
   constexpr std::size_t utf8_buffer_size = 7;
   char utf8_buffer[utf8_buffer_size];
   
   auto utf8_bytes_written 
      = xkb_keysym_to_utf8(key_sym , utf8_buffer, utf8_buffer_size);
      
   if(utf8_bytes_written > 0) {
      
      auto utf32 = xkb_keysym_to_utf32(key_sym);
      
      if(utf32 <= 127) {
         
         // Is an ascii character
         //
         addIfLessModifiersUsed(
            keymap_info.ascii_to_kaleidoscope_key_code_,
            char(utf32), 
            key_info, 
            num_modifier_bits_set
         );
       }
      
      addIfLessModifiersUsed(
         keymap_info.unicode_to_kaleidoscope_key_code_,
         utf32, 
         key_info, 
         num_modifier_bits_set
      );
         
//       std::cout << "      key_event: " << key_event 
//          << ", key_sym: " << key_sym
//          << ", kaleidoscope key: " << kaleidoscope_key_name
//          << ", utf8: " << utf8_buffer
//          << ", modifiers: " << modifier_bits
//          << " = " << getModifiersString(modifier_bits) << std::endl;
      
      return;
   }
      
   // Not a unicode keysym
      
   constexpr std::size_t keysym_name_size = 100;
   char keysym_name[keysym_name_size];
   auto n_chars_transferred = xkb_keysym_get_name(key_sym, keysym_name, keysym_name_size);
   
   if(n_chars_transferred == 0) {
      std::cerr << "Unable to get keysym name for key sym " << key_sym
         << std::endl;
      throw std::runtime_error("Unable to get keysym name");
   }
      
   addIfLessModifiersUsed(
      keymap_info.non_printable_to_kaleidoscope_key_code_,
      std::string{keysym_name}, 
      key_info, 
      num_modifier_bits_set
   );
}

void
   LayoutProcessor
      ::updateMods(struct xkb_state *key_state, int old_mods, int new_mods) 
{ 
   auto mod_changes = new_mods ^ old_mods;
   
   //std::cout << "      modifier bits: " << new_mods 
   //   << ", changes: " << mod_changes << std::endl;
      
   // Press/release modifiers
   //
   for(int mod_id = 0; mod_id < 5; ++mod_id) {
      
      if(mod_changes & (1 << mod_id)) {
         
         auto key_dir = XKB_KEY_UP;
         if(new_mods & (1 << mod_id)) {
            key_dir = XKB_KEY_DOWN;
         }
         
         //std::cout << "         updating modifier " << mod_id
         //   << "=" << mod_key_codes[mod_id] << ", dir: " 
         //   << key_dir << std::endl;
         xkb_state_update_key(key_state, 
                              mod_key_codes[mod_id],
                              key_dir);
      }
   }
   
//    auto mod_mask 
//       = xkb_state_serialize_mods(key_state, XKB_STATE_MODS_EFFECTIVE);
//       
//    std::cout << "      mod mask: " << mod_mask << std::endl;
}


void 
   LayoutProcessor
      ::parseKeymap(KeymapInfo &keymap_info,
                    struct xkb_keymap *keymap, 
                    struct xkb_rule_names *rule_names)
{ 
   xkb_mod_index_t num_mods = xkb_keymap_num_mods(keymap);
   
   std::cout << "Keymap " << rule_names->layout << ":" << rule_names->variant << std::endl;
   std::cout << "   " << num_mods << " mods: ";
   for(xkb_mod_index_t mod_id = 0; mod_id < num_mods; ++mod_id) {
      const char *mod_name = xkb_keymap_mod_get_name(keymap, mod_id);
      std::cout << mod_name << ", ";
   }
   std::cout << std::endl;
      
   xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(keymap);
   
   std::cout << "   " << num_layouts << " layouts: ";
   for(xkb_layout_index_t layout_id = 0; layout_id < num_layouts; ++layout_id) {
      const char *layout_name = xkb_keymap_layout_get_name(keymap, layout_id);
      std::cout << layout_name << ", ";
   }
   std::cout << std::endl; 
   
   //std::cout << "   keymap:" << std::endl;
   
   auto key_state = xkb_state_new(keymap);
   
   // Iterate over all keys
         
   int old_modifier_bits = 0;
   
   for(const auto &entry: event_code_to_hid_code) {
      
      auto key_event = entry.first;
      auto key_code = keyEventToKeyCode(key_event);
      
      //xkb_layout_index_t num_layouts
      //= xkb_keymap_num_layouts_for_key(keymap, key_code);
      
      // Iterate over all modifier combinations
      //
      //
      for(int modifier_bits = 0; modifier_bits < 32; ++modifier_bits) {

         this->updateMods(key_state, old_modifier_bits, modifier_bits);
         
         old_modifier_bits = modifier_bits;

         auto key_sym = xkb_state_key_get_one_sym(key_state, key_code);
            
         this->handleKeysym(keymap_info, 
                            key_event, 
                            modifier_bits,
                            key_sym);
      }
   }
   
   keymap_info.dump();
   keymap_info.writeConfigFile(settings_);
}

void 
   LayoutProcessor
      ::processLayout(const char *layout, const char *variant)
{ 
   struct xkb_rule_names rule_names;
      rule_names.rules = "evdev";
      rule_names.model = "pc105";
      rule_names.layout = layout;
      rule_names.variant = variant;
      rule_names.options = "";
   
   auto keymap = xkb_keymap_new_from_names(xkb_context_, 
                                           &rule_names, 
                                           XKB_MAP_COMPILE_PLACEHOLDER);
   
   if(!keymap) {
      std::cerr << "Error opening keymap " 
         << layout << ":" << variant << std::endl;
   }
   else {
      KeymapInfo keymap_info;
      keymap_info.layout_ = layout;
      keymap_info.variant_ = variant;
      this->parseKeymap(keymap_info, keymap, &rule_names);
      xkb_keymap_unref(keymap);
      keymap = nullptr;
   }
}

void  
   LayoutProcessor
      ::readKeyboardLayouts() 
{
    boost::char_separator<char> sep(", \n");
   
//    std::string keyboard_layouts_string
//       = getStdoutFromCommand("localectl list-x11-keymap-layouts");
//       
//    boost::tokenizer<boost::char_separator<char> > 
//       layouts(keyboard_layouts_string, sep);
   
   std::vector<std::string> layouts = { "de" };
      
   for(const auto &layout: layouts) {
      
      std::ostringstream s;
      s << "localectl list-x11-keymap-variants " << layout;
      
      std::string variants_string = getStdoutFromCommand(s.str());
      
      // Search for the error msg "Couldn't find any entries."
      // or any other string that contains spaces.
      //
      std::size_t found = variants_string.find(" ");
      if(found != std::string::npos) {
         this->processLayout(layout.c_str(), "");
         continue;
      }
      
      boost::tokenizer<boost::char_separator<char> > 
         variants(variants_string, sep);
         
      //std::cout << layout << std::endl;
         
      for(const auto &variant: variants) {
         //std::cout << "   " << variant << std::endl;
         
         this->processLayout(layout.c_str(), variant.c_str());
      }
   }
}
int main(int argc, const char** argv) {
   
   Settings settings;
   settings.parse(argc, argv);
   
   LayoutProcessor lp(settings);
   
   lp.readKeyboardLayouts();
}
